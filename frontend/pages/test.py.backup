import streamlit as st
import time
import requests
from gaze_tracker import capture_webcam
from questions import QUESTIONS

# Appel de la route get_last_exam et stockage dans des variables non utilisées
try:
    last_exam_response = requests.get("http://localhost:8000/get_last_exam")
    last_exam_data = last_exam_response.json() if last_exam_response.status_code == 200 else None
    # Ces variables ne sont pas utilisées ailleurs dans le code
except Exception as e:
    # Si l'appel échoue, on continue simplement sans utiliser les données
    pass

# Configuration de la page
st.set_page_config(page_title="Examen en cours", layout="wide")

# CSS personnalisé pour les animations
st.markdown("""
<style>
    /* Animation de victoire */
    @keyframes victory {
        0% { transform: scale(1); }
        50% { transform: scale(1.2); }
        100% { transform: scale(1); }
    }
    
    .victory-animation {
        text-align: center;
        color: #2ECC71;
        font-size: 3em;
        font-weight: bold;
        animation: victory 1s ease-in-out infinite;
    }
    
    /* Animation de défaite */
    @keyframes defeat {
        0% { transform: translateX(0); }
        25% { transform: translateX(-10px); }
        50% { transform: translateX(10px); }
        100% { transform: translateX(0); }
    }
    
    .defeat-animation {
        text-align: center;
        color: #E74C3C;
        font-size: 3em;
        font-weight: bold;
        animation: defeat 0.5s ease-in-out infinite;
    }
    
    /* Style des boutons de navigation */
    .nav-btn {
        background: linear-gradient(45deg, #2C3E50, #3498DB);
        color: white;
        border: none;
        border-radius: 20px;
        padding: 0.5rem 2rem;
        transition: all 0.3s;
        width: 200px;
        margin: 0.5rem;
    }
    
    .nav-btn:hover {
        background: linear-gradient(45deg, #3498DB, #2C3E50);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
    }
    
    /* Style pour les questions */
    .question-container {
        background: rgba(44, 62, 80, 0.1);
        padding: 20px;
        border-radius: 15px;
        margin-bottom: 2rem;
    }
    
    .progress-bar {
        height: 10px;
        background: linear-gradient(45deg, #3498DB, #2ECC71);
        border-radius: 5px;
        transition: width 0.3s ease;
    }
    
    .question-number {
        text-align: center;
        font-size: 1.2em;
        color: #3498DB;
        margin-bottom: 1rem;
    }
</style>
""", unsafe_allow_html=True)

def main():
    # Récupération de l'examen sélectionné
    if 'selected_exam' in st.session_state:
        exam = st.session_state.selected_exam
    else:
        # Utilisation de la nouvelle API de query_params
        query_params = st.query_params
        if 'exam' in query_params:
            exam = query_params['exam']
        else:
            st.error("Aucun examen sélectionné. Veuillez retourner à la page de sélection d'examen.")
            if st.button("Retour à la sélection d'examen"):
                st.switch_page("pages/exam.py")
            st.stop()
    
    # Récupération des questions de l'examen sélectionné
    questions = QUESTIONS[exam]
    total_questions = len(questions)
    
    # Initialisation des variables de session si ce n'est pas déjà fait
    if 'current_question_index' not in st.session_state:
        st.session_state.current_question_index = 0
    
    if 'answers' not in st.session_state:
        st.session_state.answers = {}
    
    if 'exam_finished' not in st.session_state:
        st.session_state.exam_finished = False
    
    # Affichage du titre et de la progression
    st.title(f"Examen: {exam}")
    
    # Si l'examen est terminé, afficher le résultat
    if st.session_state.exam_finished:
        display_results(questions)
    else:
        # Affichage de la barre de progression
        progress = (st.session_state.current_question_index + 1) / total_questions
        st.progress(progress)
        st.markdown(f"<div class='question-number'>Question {st.session_state.current_question_index + 1} / {total_questions}</div>", unsafe_allow_html=True)
        
        # Affichage de la question actuelle
        display_question(questions)

def display_question(questions):
    """Affiche la question actuelle et les boutons de navigation"""
    current_index = st.session_state.current_question_index
    total_questions = len(questions)
    
    # Récupération de la question actuelle
    q = questions[current_index]
    
    # Conteneur de la question
    st.markdown("<div class='question-container'>", unsafe_allow_html=True)
    st.subheader(f"{q['question']}")
    
    # Affichage des options de réponse
    selected = st.radio(
        "Choisissez votre réponse",
        q['answers'],
        key=f"q_{current_index}_{time.time()}",  # Clé dynamique pour éviter les problèmes de cache
        index=None
    )
    
    # Enregistrement de la réponse si sélectionnée
    if selected:
        st.session_state.answers[current_index] = selected
    
    st.markdown("</div>", unsafe_allow_html=True)
    
    # Boutons de navigation
    col1, col2 = st.columns(2)
    
    with col1:
        if current_index > 0:
            if st.button("⬅️ Question précédente"):
                st.session_state.current_question_index -= 1
                st.experimental_rerun()
    
    with col2:
        if current_index < total_questions - 1:
            next_btn_label = "Question suivante ➡️"
            if st.button(next_btn_label):
                st.session_state.current_question_index += 1
                st.experimental_rerun()
        else:
            # Bouton de soumission pour la dernière question
            if st.button("✅ Terminer l'examen"):
                # Activation du système de détection de triche
                with st.spinner("Analyse du comportement pendant l'examen en cours..."):
                    cheat_percentage = capture_webcam()
                    st.session_state.cheat_percentage = cheat_percentage
                
                # Calcul du score
                score = calculate_score(questions, st.session_state.answers)
                st.session_state.score = score
                st.session_state.exam_name = st.session_state.selected_exam
                st.session_state.exam_finished = True
                
                st.success("Examen terminé ! Vos résultats sont en cours de calcul...")
                time.sleep(1)  # Petite pause pour l'effet
                st.experimental_rerun()

def display_results(questions):
    """Affiche les résultats de l'examen avec animation"""
    score = st.session_state.score
    cheat_percentage = st.session_state.get('cheat_percentage', 0)
    
    # Déterminer si c'est une victoire ou une défaite
    is_victory = score >= 60 and cheat_percentage < 50
    
    # Affichage du résultat avec animation
    if is_victory:
        st.markdown(f"<div class='victory-animation'>FÉLICITATIONS!</div>", unsafe_allow_html=True)
        st.balloons()  # Animation de ballons
    else:
        st.markdown(f"<div class='defeat-animation'>ÉCHEC</div>", unsafe_allow_html=True)
    
    # Afficher le score
    st.markdown(f"<h2 style='text-align: center;'>Votre score: {score:.1f}%</h2>", unsafe_allow_html=True)
    
    # Afficher le taux de triche
    if cheat_percentage > 0:
        st.markdown(f"<h3 style='text-align: center;'>Taux de triche détecté: {cheat_percentage:.1f}%</h3>", unsafe_allow_html=True)
    
    # Résumé des réponses
    st.subheader("Vos réponses:")
    
    for i, q in enumerate(questions):
        correct = q['correct_answer']
        user_answer = st.session_state.answers.get(i, "Pas de réponse")
        is_correct = user_answer == correct
        
        col1, col2, col3 = st.columns([3, 1, 1])
        with col1:
            st.write(f"Q{i+1}: {q['question']}")
        with col2:
            st.write(f"Votre réponse: {user_answer}")
        with col3:
            if is_correct:
                st.success("Correct ✓")
            else:
                st.error(f"Incorrect ✗ (Réponse: {correct})")
    
    # Bouton pour retourner à l'accueil
    if st.button("Retour à l'accueil"):
        # Réinitialiser les variables de session liées à l'examen
        st.session_state.current_question_index = 0
        st.session_state.answers = {}
        st.session_state.exam_finished = False
        # Redirection vers la page d'accueil
        st.switch_page("pages/home.py")

def calculate_score(questions, answers):
    """Calcule le score basé sur les réponses fournies"""
    score = 0
    total = len(questions)
    
    for i, q in enumerate(questions):
        if i in answers and answers[i] == q['correct_answer']:
            score += 1
    
    return (score / total) * 100 if total > 0 else 0

if __name__ == "__main__":
    main()
    
    .question-number {
        text-align: center;
        font-size: 1.2em;
        color: #3498DB;
        margin-bottom: 1rem;
    }
</style>
""", unsafe_allow_html=True)

def main():
    # Récupération de l'examen sélectionné
    if 'selected_exam' in st.session_state:
        exam = st.session_state.selected_exam
    else:
        # Utilisation de la nouvelle API de query_params
        query_params = st.query_params
        if 'exam' in query_params:
            exam = query_params['exam']
        else:
            st.error("Aucun examen sélectionné. Veuillez retourner à la page de sélection d'examen.")
            if st.button("Retour à la sélection d'examen"):
                st.switch_page("pages/exam.py")
            st.stop()
    
    # Récupération des questions de l'examen sélectionné
    questions = QUESTIONS[exam]
    total_questions = len(questions)
    
    # Initialisation des variables de session si ce n'est pas déjà fait
    if 'current_question_index' not in st.session_state:
        st.session_state.current_question_index = 0
    
    if 'answers' not in st.session_state:
        st.session_state.answers = {}
    
    if 'exam_finished' not in st.session_state:
        st.session_state.exam_finished = False
    
    # Affichage du titre et de la progression
    st.title(f"Examen: {exam}")
    
    # Si l'examen est terminé, afficher le résultat
    if st.session_state.exam_finished:
        display_results(questions)
    else:
        # Affichage de la barre de progression
        progress = (st.session_state.current_question_index + 1) / total_questions
        st.progress(progress)
        st.markdown(f"<div class='question-number'>Question {st.session_state.current_question_index + 1} / {total_questions}</div>", unsafe_allow_html=True)
        
        # Affichage de la question actuelle
        display_question(questions)

def display_question(questions):
    """Affiche la question actuelle et les boutons de navigation"""
    current_index = st.session_state.current_question_index
    total_questions = len(questions)
    
    # Récupération de la question actuelle
    q = questions[current_index]
    
    # Conteneur de la question
    st.markdown("<div class='question-container'>", unsafe_allow_html=True)
    st.subheader(f"{q['question']}")
    
    # Affichage des options de réponse
    selected = st.radio(
        "Choisissez votre réponse",
        q['answers'],
        key=f"q_{current_index}_{time.time()}",  # Clé dynamique pour éviter les problèmes de cache
        index=None
    )
    
    # Enregistrement de la réponse si sélectionnée
    if selected:
        st.session_state.answers[current_index] = selected
    
    st.markdown("</div>", unsafe_allow_html=True)
    
    # Boutons de navigation
    col1, col2 = st.columns(2)
    
    with col1:
        if current_index > 0:
            if st.button("⬅️ Question précédente"):
                st.session_state.current_question_index -= 1
                st.experimental_rerun()
    
    with col2:
        if current_index < total_questions - 1:
            next_btn_label = "Question suivante ➡️"
            if st.button(next_btn_label):
                st.session_state.current_question_index += 1
                st.experimental_rerun()
        else:
            # Bouton de soumission pour la dernière question
            if st.button("✅ Terminer l'examen"):
                # Activation du système de détection de triche
                with st.spinner("Analyse du comportement pendant l'examen en cours..."):
                    cheat_percentage = capture_webcam()
                    st.session_state.cheat_percentage = cheat_percentage
                
                # Calcul du score
                score = calculate_score(questions, st.session_state.answers)
                st.session_state.score = score
                st.session_state.exam_name = st.session_state.selected_exam
                st.session_state.exam_finished = True
                
                st.success("Examen terminé ! Vos résultats sont en cours de calcul...")
                time.sleep(1)  # Petite pause pour l'effet
                st.experimental_rerun()

def display_results(questions):
    """Affiche les résultats de l'examen avec animation"""
    score = st.session_state.score
    cheat_percentage = st.session_state.get('cheat_percentage', 0)
    
    # Déterminer si c'est une victoire ou une défaite
    is_victory = score >= 60 and cheat_percentage < 50
    
    # Affichage du résultat avec animation
    if is_victory:
        st.markdown(f"<div class='victory-animation'>FÉLICITATIONS!</div>", unsafe_allow_html=True)
        st.balloons()  # Animation de ballons
    else:
        st.markdown(f"<div class='defeat-animation'>ÉCHEC</div>", unsafe_allow_html=True)
    
    # Afficher le score
    st.markdown(f"<h2 style='text-align: center;'>Votre score: {score:.1f}%</h2>", unsafe_allow_html=True)
    
    # Afficher le taux de triche
    if cheat_percentage > 0:
        st.markdown(f"<h3 style='text-align: center;'>Taux de triche détecté: {cheat_percentage:.1f}%</h3>", unsafe_allow_html=True)
    
    # Résumé des réponses
    st.subheader("Vos réponses:")
    
    for i, q in enumerate(questions):
        correct = q['correct_answer']
        user_answer = st.session_state.answers.get(i, "Pas de réponse")
        is_correct = user_answer == correct
        
        col1, col2, col3 = st.columns([3, 1, 1])
        with col1:
            st.write(f"Q{i+1}: {q['question']}")
        with col2:
            st.write(f"Votre réponse: {user_answer}")
        with col3:
            if is_correct:
                st.success("Correct ✓")
            else:
                st.error(f"Incorrect ✗ (Réponse: {correct})")
    
    # Bouton pour retourner à l'accueil
    if st.button("Retour à l'accueil"):
        # Réinitialiser les variables de session liées à l'examen
        st.session_state.current_question_index = 0
        st.session_state.answers = {}
        st.session_state.exam_finished = False
        # Redirection vers la page d'accueil
        st.switch_page("pages/home.py")

def calculate_score(questions, answers):
    """Calcule le score basé sur les réponses fournies"""
    score = 0
    total = len(questions)
    
    for i, q in enumerate(questions):
        if i in answers and answers[i] == q['correct_answer']:
            score += 1
    
    return (score / total) * 100 if total > 0 else 0

if __name__ == "__main__":
    main()
            else:
                st.error(f"Incorrect ✗ (Réponse: {correct})")
    
    # Bouton pour retourner à l'accueil
    if st.button("Retour à l'accueil"):
        # Réinitialiser les variables de session liées à l'examen
        st.session_state.current_question_index = 0
        st.session_state.answers = {}
        st.session_state.exam_finished = False
        # Redirection vers la page d'accueil
        st.switch_page("pages/home.py")

def calculate_score(questions, answers):
    """Calcule le score basé sur les réponses fournies"""
    score = 0
    total = len(questions)
    
    for i, q in enumerate(questions):
        if i in answers and answers[i] == q['correct_answer']:
            score += 1
    
    return (score / total) * 100 if total > 0 else 0

if __name__ == "__main__":
    main()