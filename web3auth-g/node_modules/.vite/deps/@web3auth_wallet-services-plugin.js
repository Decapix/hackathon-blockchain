import {
  ADAPTER_EVENTS,
  ADAPTER_STATUS,
  BasePostMessageStream,
  CHAIN_NAMESPACES,
  COMMUNICATION_JRPC_METHODS,
  COMMUNICATION_NOTIFICATIONS,
  CONFIRMATION_STRATEGY,
  EVM_PLUGINS,
  EthereumProviderError,
  FEATURES_CONFIRM_WINDOW,
  FEATURES_DEFAULT_POPUP_WINDOW,
  FEATURES_PROVIDER_CHANGE_WINDOW,
  JRPCEngine,
  ObjectMultiplex,
  PLUGIN_EVENTS,
  PLUGIN_NAMESPACES,
  PLUGIN_STATUS,
  PROVIDER_JRPC_METHODS,
  PROVIDER_NOTIFICATIONS,
  SETUP_COMPLETE,
  SafeEventEmitter,
  THEME_MODES,
  WALLET_ADAPTERS,
  WalletServicesPluginError,
  _defineProperty,
  _objectSpread2,
  createIdRemapMiddleware,
  createLoggerMiddleware2 as createLoggerMiddleware,
  createStreamMiddleware,
  getPopupFeatures2 as getPopupFeatures,
  getRpcPromiseCallback,
  loglevel2 as loglevel,
  randomId,
  require_loglevel,
  require_pump,
  rpcErrors
} from "./chunk-VGWJKPGH.js";
import "./chunk-GMQWRXFX.js";
import "./chunk-ATDVI3CM.js";
import "./chunk-CFIX2DL5.js";
import {
  __commonJS,
  __toESM
} from "./chunk-256EKJAK.js";

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/@web3auth/ws-embed/dist/embed.esm.js
var import_pump = __toESM(require_pump());
var import_loglevel = __toESM(require_loglevel());
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var SOLANA_METHOD_TYPES = {
  GET_ACCOUNTS: "getAccounts",
  SOLANA_REQUEST_ACCOUNTS: "solana_requestAccounts",
  SEND_TRANSACTION: "solana_sendTransaction",
  SIGN_TRANSACTION: "solana_signTransaction",
  SIGN_ALL_TRANSACTIONS: "solana_signAllTransactions",
  SIGN_MESSAGE: "solana_signMessage"
};
var SOLANA_CHAIN_IDS = {
  SOLANA_MAINNET: "0x65",
  SOLANA_TESTNET: "0x66",
  SOLANA_DEVNET: "0x67"
};
var EVM_METHOD_TYPES = {
  GET_ACCOUNTS: "eth_accounts",
  ETH_TRANSACTION: "eth_sendTransaction",
  ETH_ESTIMATE_USER_OPERATION_GAS: "eth_estimateUserOperationGas",
  ETH_REQUEST_ACCOUNTS: "eth_requestAccounts",
  ETH_SEND_RAW_TRANSACTION: "eth_sendRawTransaction",
  ETH_SIGN: "eth_sign",
  ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
  PERSONAL_SIGN: "personal_sign",
  ETH_GET_TRANSACTION_COUNT: "eth_getTransactionCount",
  ETH_GET_TRANSACTION_BY_HASH: "eth_getTransactionByHash",
  ETH_GET_TRANSACTION_RECEIPT: "eth_getTransactionReceipt",
  WATCH_ASSET: "wallet_watchAsset",
  ETH_GET_BLOCK_BY_HASH: "eth_getBlockByHash",
  ETH_GET_CODE: "eth_getCode",
  ETH_GET_GAS_PRICE: "eth_gasPrice",
  SWITCH_CHAIN: "wallet_switchEthereumChain",
  ADD_CHAIN: "wallet_addEthereumChain"
};
function isStream(stream) {
  return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
}
function isWritableStream(stream) {
  return isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
}
function isReadableStream(stream) {
  return isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
}
function isDuplexStream(stream) {
  return isWritableStream(stream) && isReadableStream(stream);
}
var messages = {
  errors: {
    disconnected: () => "Web3Auth: Lost connection to Web3Auth.",
    permanentlyDisconnected: () => "Web3Auth: Disconnected from iframe. Page reload required.",
    unsupportedSync: (method) => `Web3Auth: The Web3Auth Ethereum provider does not support synchronous methods like ${method} without a callback parameter.`,
    invalidDuplexStream: () => "Must provide a Node.js-style duplex stream.",
    invalidOptions: (maxEventListeners) => `Invalid options. Received: { maxEventListeners: ${maxEventListeners}}`,
    invalidRequestArgs: () => `Expected a single, non-array, object argument.`,
    invalidRequestMethod: () => `'args.method' must be a non-empty string.`,
    invalidRequestParams: () => `'args.params' must be an object or array if provided.`,
    invalidLoggerObject: () => `'args.logger' must be an object if provided.`,
    invalidLoggerMethod: (method) => `'args.logger' must include required method '${method}'.`
  },
  info: {
    connected: (chainId) => `Web3Auth: Connected to chain with ID "${chainId}".`
  }
};
var log = import_loglevel.default.getLogger("ws-embed");
function createErrorMiddleware() {
  return (req, res, next) => {
    if (typeof req.method !== "string" || !req.method) {
      res.error = rpcErrors.invalidRequest({
        message: `The request 'method' must be a non-empty string.`,
        data: _objectSpread2(_objectSpread2({}, req || {}), {}, {
          cause: `The request 'method' must be a non-empty string.`
        })
      });
    }
    next((done) => {
      const {
        error
      } = res;
      if (!error) {
        return done();
      }
      log.error(`Ws-Embed - RPC Error: ${error.message}`, error);
      return done();
    });
  };
}
function logStreamDisconnectWarning(remoteLabel, error, emitter) {
  let warningMsg = `Web3Auth: Lost connection to "${remoteLabel}".`;
  if (error !== null && error !== void 0 && error.stack) {
    warningMsg += `
${error.stack}`;
  }
  log.warn(warningMsg);
  if (emitter && emitter.listenerCount("error") > 0) {
    emitter.emit("error", warningMsg);
  }
}
var EMITTED_NOTIFICATIONS = [
  "eth_subscription"
  // per eth-json-rpc-filters/subscriptionManager
];
var BaseProvider = class extends SafeEventEmitter {
  constructor(connectionStream, {
    maxEventListeners = 100,
    jsonRpcStreamName = "provider"
  }) {
    super();
    _defineProperty(this, "rpcEngine", void 0);
    _defineProperty(this, "jsonRpcConnectionEvents", void 0);
    _defineProperty(this, "isWeb3Auth", void 0);
    _defineProperty(this, "state", void 0);
    if (!isDuplexStream(connectionStream)) {
      throw new Error(messages.errors.invalidDuplexStream());
    }
    this.isWeb3Auth = true;
    this.setMaxListeners(maxEventListeners);
    this.handleConnect = this.handleConnect.bind(this);
    this.handleDisconnect = this.handleDisconnect.bind(this);
    this.handleStreamDisconnect = this.handleStreamDisconnect.bind(this);
    this.rpcRequest = this.rpcRequest.bind(this);
    this.initializeState = this.initializeState.bind(this);
    this.request = this.request.bind(this);
    this.sendAsync = this.sendAsync.bind(this);
    this.send = this.send.bind(this);
    const mux = new ObjectMultiplex();
    (0, import_pump.default)(connectionStream, mux, connectionStream, this.handleStreamDisconnect.bind(this, "Web3Auth"));
    mux.ignoreStream("phishing");
    const jsonRpcConnection = createStreamMiddleware();
    (0, import_pump.default)(jsonRpcConnection.stream, mux.createStream(jsonRpcStreamName), jsonRpcConnection.stream, this.handleStreamDisconnect.bind(this, "Web3Auth RpcProvider"));
    const rpcEngine = new JRPCEngine();
    rpcEngine.push(createIdRemapMiddleware());
    rpcEngine.push(createErrorMiddleware());
    rpcEngine.push(createLoggerMiddleware({
      origin: location.origin
    }));
    rpcEngine.push(jsonRpcConnection.middleware);
    this.rpcEngine = rpcEngine;
    this.jsonRpcConnectionEvents = jsonRpcConnection.events;
  }
  /**
   * Submits an RPC request for the given method, with the given params.
   * Resolves with the result of the method call, or rejects on error.
   *
   * @param args - The RPC request arguments.
   * @returns A Promise that resolves with the result of the RPC method,
   * or rejects if an error is encountered.
   */
  async request(args) {
    if (!args || typeof args !== "object" || Array.isArray(args)) {
      throw rpcErrors.invalidRequest({
        message: messages.errors.invalidRequestArgs(),
        data: _objectSpread2(_objectSpread2({}, args || {}), {}, {
          cause: messages.errors.invalidRequestArgs()
        })
      });
    }
    const {
      method,
      params
    } = args;
    if (typeof method !== "string" || method.length === 0) {
      throw rpcErrors.invalidRequest({
        message: messages.errors.invalidRequestMethod(),
        data: _objectSpread2(_objectSpread2({}, args || {}), {}, {
          cause: messages.errors.invalidRequestArgs()
        })
      });
    }
    if (params !== void 0 && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
      throw rpcErrors.invalidRequest({
        message: messages.errors.invalidRequestParams(),
        data: _objectSpread2(_objectSpread2({}, args || {}), {}, {
          cause: messages.errors.invalidRequestArgs()
        })
      });
    }
    return new Promise((resolve, reject) => {
      this.rpcRequest({
        method,
        params
      }, getRpcPromiseCallback(resolve, reject));
    });
  }
  /**
   * Submits an RPC request per the given JSON-RPC request object.
   *
   * @param payload - The RPC request object.
   * @param cb - The callback function.
   */
  send(payload, callback) {
    this.rpcRequest(payload, callback);
  }
  /**
   * Submits an RPC request per the given JSON-RPC request object.
   *
   * @param payload - The RPC request object.
   * @param cb - The callback function.
   */
  sendAsync(payload) {
    return new Promise((resolve, reject) => {
      this.rpcRequest(payload, getRpcPromiseCallback(resolve, reject));
    });
  }
  /**
   * Called when connection is lost to critical streams.
   *
   * emits InpageProvider#disconnect
   */
  handleStreamDisconnect(streamName, error) {
    logStreamDisconnectWarning(streamName, error, this);
    this.handleDisconnect(false, error ? error.message : void 0);
  }
  // Private Methods
  //= ===================
  /**
   * Constructor helper.
   * Populates initial state by calling 'wallet_getProviderState' and emits
   * necessary events.
   */
  /**
   * Internal RPC method. Forwards requests to background via the RPC engine.
   * Also remap ids inbound and outbound
   */
  /**
   * When the provider becomes connected, updates internal state and emits
   * required events. Idempotent.
   *
   * @param chainId - The ID of the newly connected chain.
   * emits InPageProvider#connect
   */
  /**
   * When the provider becomes disconnected, updates internal state and emits
   * required events. Idempotent with respect to the isRecoverable parameter.
   *
   * Error codes per the CloseEvent status codes as required by EIP-1193:
   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
   *
   * @param isRecoverable - Whether the disconnection is recoverable.
   * @param errorMessage - A custom error message.
   * emits InpageProvider#disconnect
   */
};
var WS_EMBED_BUILD_ENV = {
  PRODUCTION: "production",
  STAGING: "staging",
  DEVELOPMENT: "development",
  TESTING: "testing"
};
var BUTTON_POSITION = {
  BOTTOM_LEFT: "bottom-left",
  TOP_LEFT: "top-left",
  BOTTOM_RIGHT: "bottom-right",
  TOP_RIGHT: "top-right"
};
var PopupHandler = class extends SafeEventEmitter {
  constructor({
    url,
    target,
    features,
    timeout = 3e4
  }) {
    super();
    _defineProperty(this, "url", void 0);
    _defineProperty(this, "target", void 0);
    _defineProperty(this, "features", void 0);
    _defineProperty(this, "window", void 0);
    _defineProperty(this, "windowTimer", void 0);
    _defineProperty(this, "iClosedWindow", void 0);
    _defineProperty(this, "timeout", void 0);
    this.url = url;
    this.target = target || "_blank";
    this.features = features || getPopupFeatures(FEATURES_DEFAULT_POPUP_WINDOW);
    this.window = void 0;
    this.windowTimer = void 0;
    this.iClosedWindow = false;
    this.timeout = timeout;
    this._setupTimer();
  }
  _setupTimer() {
    this.windowTimer = Number(setInterval(() => {
      if (this.window && this.window.closed) {
        clearInterval(this.windowTimer);
        setTimeout(() => {
          if (!this.iClosedWindow) {
            this.emit("close");
          }
          this.iClosedWindow = false;
          this.window = void 0;
        }, this.timeout);
      }
      if (this.window === void 0) clearInterval(this.windowTimer);
    }, 500));
  }
  open() {
    var _this$window;
    this.window = window.open(this.url.href, this.target, this.features);
    if ((_this$window = this.window) !== null && _this$window !== void 0 && _this$window.focus) this.window.focus();
  }
  close() {
    this.iClosedWindow = true;
    if (this.window) this.window.close();
  }
  redirect(locationReplaceOnRedirect) {
    if (locationReplaceOnRedirect) {
      window.location.replace(this.url.href);
    } else {
      window.location.href = this.url.href;
    }
  }
};
var CommunicationProvider = class _CommunicationProvider extends BaseProvider {
  constructor(connectionStream, {
    maxEventListeners = 100,
    jsonRpcStreamName = "provider"
  }, state) {
    super(connectionStream, {
      maxEventListeners,
      jsonRpcStreamName
    });
    _defineProperty(this, "tryWindowHandle", void 0);
    _defineProperty(this, "windowRefs", void 0);
    _defineProperty(this, "iframeUrl", void 0);
    _defineProperty(this, "iframeId", void 0);
    this.state = _objectSpread2(_objectSpread2({}, _CommunicationProvider.defaultState), state);
    this.iframeUrl = "";
    this.iframeId = "";
    this.windowRefs = /* @__PURE__ */ new Map();
    this.on("connect", () => {
      this.state.isConnected = true;
    });
    const notificationHandler = (payload) => {
      const {
        method,
        params
      } = payload;
      if (method === COMMUNICATION_NOTIFICATIONS.IFRAME_STATUS) {
        const {
          isFullScreen,
          rid
        } = params;
        this.displayIframe({
          isFull: isFullScreen,
          rid
        }, true);
      } else if (method === COMMUNICATION_NOTIFICATIONS.CLOSE_WINDOW) {
        this.handleCloseWindow(params);
      } else if (method === COMMUNICATION_NOTIFICATIONS.USER_LOGGED_IN) {
        const {
          currentLoginProvider
        } = params;
        this.state.isLoggedIn = true;
        this.state.currentLoginProvider = currentLoginProvider;
      } else if (method === COMMUNICATION_NOTIFICATIONS.USER_LOGGED_OUT) {
        this.state.isLoggedIn = false;
        this.state.currentLoginProvider = null;
        this.displayIframe({
          isFull: false
        }, true);
      } else if (method === COMMUNICATION_NOTIFICATIONS.TOGGLE_WIDGET_BUTTON) {
        const {
          show
        } = params;
        this.state.widgetVisibility = show;
        this.displayIframe();
      } else if (method === COMMUNICATION_NOTIFICATIONS.ALLOW_WALLET_SERVICE) {
        const {
          allow
        } = params;
        this.state.allowWalletService = allow;
      }
    };
    this.jsonRpcConnectionEvents.on("notification", notificationHandler);
  }
  get isLoggedIn() {
    return this.state.isLoggedIn;
  }
  get isIFrameFullScreen() {
    return this.state.isIFrameFullScreen;
  }
  get allowWalletService() {
    return this.state.allowWalletService;
  }
  /**
   * Returns whether the inPage provider is connected to Torus.
   */
  isConnected() {
    return this.state.isConnected;
  }
  async initializeState(params) {
    try {
      const {
        torusUrl,
        torusIframeId
      } = params;
      this.iframeUrl = torusUrl;
      this.iframeId = torusIframeId;
      const {
        currentLoginProvider,
        isLoggedIn
      } = await this.request({
        method: COMMUNICATION_JRPC_METHODS.GET_PROVIDER_STATE,
        params: []
      });
      if (isLoggedIn) this.handleConnect(currentLoginProvider, isLoggedIn);
    } catch (error) {
      log.error("Web3Auth: Failed to get initial state. Please report this bug.", error);
    } finally {
      log.info("initialized communication state");
      this.state.initialized = true;
    }
  }
  displayIframe({
    isFull = false,
    rid = ""
  } = {}, walletRequest = false) {
    const style = {};
    if (!isFull) {
      style.display = this.state.widgetVisibility ? "block" : "none";
      style.height = this.state.widgetVisibility ? "70px" : "0px";
      style.width = this.state.widgetVisibility ? "70px" : "0px";
      switch (this.state.buttonPosition) {
        case BUTTON_POSITION.TOP_LEFT:
          style.top = "0px";
          style.left = "0px";
          style.right = "auto";
          style.bottom = "auto";
          break;
        case BUTTON_POSITION.TOP_RIGHT:
          style.top = "0px";
          style.right = "0px";
          style.left = "auto";
          style.bottom = "auto";
          break;
        case BUTTON_POSITION.BOTTOM_RIGHT:
          style.bottom = "0px";
          style.right = "0px";
          style.top = "auto";
          style.left = "auto";
          break;
        case BUTTON_POSITION.BOTTOM_LEFT:
        default:
          style.bottom = "0px";
          style.left = "0px";
          style.top = "auto";
          style.right = "auto";
          break;
      }
    } else {
      style.display = "block";
      style.width = "100%";
      style.height = "100%";
      style.top = "0px";
      style.right = "0px";
      style.left = "0px";
      style.bottom = "0px";
    }
    const iframe = document.getElementById(this.iframeId);
    Object.assign(iframe.style, style);
    this.state.isIFrameFullScreen = isFull;
    if (!walletRequest) {
      this.request({
        method: COMMUNICATION_JRPC_METHODS.IFRAME_STATUS,
        params: {
          isIFrameFullScreen: isFull,
          rid
        }
      });
    }
  }
  /**
   * Scenarios:
   * - Login request or pre-open confirmation windows
   * We try to open here or send a rpc request to iframe that window is blocked.
   */
  async handleWindow(windowId, {
    url,
    target,
    features,
    timeout
  } = {}) {
    const finalUrl = new URL(url || `${this.iframeUrl}/redirect?windowId=${windowId}&sessionNamespace=${window.location.hostname}`);
    const handledWindow = new PopupHandler({
      url: finalUrl,
      target,
      features,
      timeout
    });
    handledWindow.open();
    if (!handledWindow.window) {
      this.displayIframe({
        isFull: true
      });
      this.request({
        method: COMMUNICATION_JRPC_METHODS.WINDOW_BLOCKED,
        params: {
          windowId,
          finalUrl: finalUrl.href
        }
      });
      return;
    }
    this.windowRefs.set(windowId, handledWindow);
    handledWindow.once("close", () => {
      this.windowRefs.delete(windowId);
      this.request({
        method: COMMUNICATION_JRPC_METHODS.CLOSED_WINDOW,
        params: {
          windowId
        }
      });
    });
  }
  /**
   * Internal RPC method. Forwards requests to background via the RPC engine.
   * Also remap ids inbound and outbound
   */
  rpcRequest(payload, callback) {
    const cb = callback;
    const _payload = payload;
    if (!Array.isArray(_payload)) {
      if (!_payload.jsonrpc) {
        _payload.jsonrpc = "2.0";
      }
    }
    this.rpcEngine.handle(_payload, cb);
  }
  /**
   * When the provider becomes connected, updates internal state and emits
   * required events. Idempotent.
   *
   * @param currentLoginProvider - The login Provider
   * emits TorusInpageProvider#connect
   */
  handleConnect(currentLoginProvider, isLoggedIn) {
    if (!this.state.isConnected) {
      this.state.isConnected = true;
      this.emit("connect", {
        currentLoginProvider,
        isLoggedIn
      });
      log.debug(messages.info.connected(currentLoginProvider));
    }
  }
  /**
   * When the provider becomes disconnected, updates internal state and emits
   * required events. Idempotent with respect to the isRecoverable parameter.
   *
   * Error codes per the CloseEvent status codes as required by EIP-1193:
   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
   *
   * @param isRecoverable - Whether the disconnection is recoverable.
   * @param errorMessage - A custom error message.
   * emits TorusInpageProvider#disconnect
   */
  handleDisconnect(isRecoverable, errorMessage) {
    if (this.state.isConnected || !this.state.isPermanentlyDisconnected && !isRecoverable) {
      this.state.isConnected = false;
      let error;
      if (isRecoverable) {
        error = new EthereumProviderError(
          1013,
          // Try again later
          errorMessage || messages.errors.disconnected()
        );
        log.debug(error);
      } else {
        error = new EthereumProviderError(
          1011,
          // Internal error
          errorMessage || messages.errors.permanentlyDisconnected()
        );
        log.error(error);
        this.state.currentLoginProvider = null;
        this.state.isLoggedIn = false;
        this.state.widgetVisibility = false;
        this.state.isIFrameFullScreen = false;
        this.state.isPermanentlyDisconnected = true;
      }
      this.emit("disconnect", error);
    }
  }
  handleCloseWindow(params) {
    const {
      windowId
    } = params;
    if (this.windowRefs.has(windowId)) {
      this.windowRefs.get(windowId).close();
      this.windowRefs.delete(windowId);
    }
  }
};
_defineProperty(CommunicationProvider, "defaultState", {
  buttonPosition: "bottom-left",
  currentLoginProvider: null,
  isIFrameFullScreen: false,
  widgetVisibility: false,
  initialized: false,
  isLoggedIn: false,
  isPermanentlyDisconnected: false,
  isConnected: false,
  hasEmittedConnection: false,
  allowWalletService: false
});
var htmlToElement = (html) => {
  const template = window.document.createElement("template");
  const trimmedHtml = html.trim();
  template.innerHTML = trimmedHtml;
  return template.content.firstChild;
};
var TorusInPageProvider = class _TorusInPageProvider extends BaseProvider {
  constructor(connectionStream, {
    maxEventListeners = 100,
    jsonRpcStreamName = "provider"
  }) {
    super(connectionStream, {
      maxEventListeners,
      jsonRpcStreamName
    });
    _defineProperty(this, "chainId", void 0);
    _defineProperty(this, "selectedAddress", void 0);
    _defineProperty(this, "tryWindowHandle", void 0);
    this.state = _objectSpread2({}, _TorusInPageProvider.defaultState);
    this.selectedAddress = null;
    this.chainId = null;
    this.handleAccountsChanged = this.handleAccountsChanged.bind(this);
    this.handleChainChanged = this.handleChainChanged.bind(this);
    this.handleUnlockStateChanged = this.handleUnlockStateChanged.bind(this);
    this.on("connect", () => {
      this.state.isConnected = true;
    });
    const jsonRpcNotificationHandler = (payload) => {
      const {
        method,
        params
      } = payload;
      if (method === PROVIDER_NOTIFICATIONS.ACCOUNTS_CHANGED) {
        this.handleAccountsChanged(params);
      } else if (method === PROVIDER_NOTIFICATIONS.UNLOCK_STATE_CHANGED) {
        this.handleUnlockStateChanged(params);
      } else if (method === PROVIDER_NOTIFICATIONS.CHAIN_CHANGED) {
        this.handleChainChanged(params);
      } else if (EMITTED_NOTIFICATIONS.includes(method)) {
        this.emit("data", payload);
        this.emit("notification", params.result);
        this.emit("message", {
          type: method,
          data: params
        });
      }
    };
    this.jsonRpcConnectionEvents.on("notification", jsonRpcNotificationHandler);
  }
  /**
   * Returns whether the inpage provider is connected to Torus.
   */
  isConnected() {
    return this.state.isConnected;
  }
  // Private Methods
  //= ===================
  /**
   * Constructor helper.
   * Populates initial state by calling 'wallet_getProviderState' and emits
   * necessary events.
   */
  async initializeState() {
    try {
      const {
        accounts,
        chainId,
        isUnlocked
      } = await this.request({
        method: PROVIDER_JRPC_METHODS.GET_PROVIDER_STATE,
        params: []
      });
      this.emit("connect", {
        chainId
      });
      this.handleChainChanged({
        chainId
      });
      this.handleUnlockStateChanged({
        accounts,
        isUnlocked
      });
      this.handleAccountsChanged(accounts);
    } catch (error) {
      log.error("WsEmbed: Failed to get initial state. Please report this bug.", error);
    } finally {
      log.info("initialized provider state");
      this.state.initialized = true;
    }
  }
  /**
   * Internal RPC method. Forwards requests to background via the RPC engine.
   * Also remap ids inbound and outbound
   */
  rpcRequest(payload, callback, isInternal = false) {
    let cb = callback;
    const _payload = payload;
    if (!Array.isArray(_payload)) {
      if (!_payload.jsonrpc) {
        _payload.jsonrpc = "2.0";
      }
      if ([EVM_METHOD_TYPES.GET_ACCOUNTS, EVM_METHOD_TYPES.ETH_REQUEST_ACCOUNTS, SOLANA_METHOD_TYPES.SOLANA_REQUEST_ACCOUNTS, SOLANA_METHOD_TYPES.GET_ACCOUNTS].includes(_payload.method)) {
        cb = (err, res) => {
          this.handleAccountsChanged(res.result || [], _payload.method === "eth_accounts", isInternal);
          callback(err, res);
        };
      } else if (_payload.method === "wallet_getProviderState") {
        this.rpcEngine.handle(payload, cb);
        return;
      }
    }
    this.tryWindowHandle(_payload, cb);
  }
  /**
   * When the provider becomes connected, updates internal state and emits
   * required events. Idempotent.
   *
   * @param chainId - The ID of the newly connected chain.
   * emits TorusInpageProvider#connect
   */
  handleConnect(chainId) {
    if (!this.state.isConnected) {
      this.state.isConnected = true;
      this.emit("connect", {
        chainId
      });
      log.debug(messages.info.connected(chainId));
    }
  }
  /**
   * When the provider becomes disconnected, updates internal state and emits
   * required events. Idempotent with respect to the isRecoverable parameter.
   *
   * Error codes per the CloseEvent status codes as required by EIP-1193:
   * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
   *
   * @param isRecoverable - Whether the disconnection is recoverable.
   * @param errorMessage - A custom error message.
   * emits TorusInpageProvider#disconnect
   */
  handleDisconnect(isRecoverable, errorMessage) {
    if (this.state.isConnected || !this.state.isPermanentlyDisconnected && !isRecoverable) {
      this.state.isConnected = false;
      let error;
      if (isRecoverable) {
        error = new EthereumProviderError(
          1013,
          // Try again later
          errorMessage || messages.errors.disconnected()
        );
        log.debug(error);
      } else {
        error = new EthereumProviderError(
          1011,
          // Internal error
          errorMessage || messages.errors.permanentlyDisconnected()
        );
        log.error(error);
        this.chainId = null;
        this.state.accounts = null;
        this.selectedAddress = null;
        this.state.isUnlocked = false;
        this.state.isPermanentlyDisconnected = true;
      }
      this.emit("disconnect", error);
    }
  }
  /**
   * Called when accounts may have changed.
   */
  handleAccountsChanged(accounts, isEthAccounts = false, isInternal = false) {
    let finalAccounts = accounts;
    if (!Array.isArray(finalAccounts)) {
      log.error("WsEmbed: Received non-array accounts parameter. Please report this bug.", finalAccounts);
      finalAccounts = [];
    }
    for (const account of accounts) {
      if (typeof account !== "string") {
        log.error("WsEmbed: Received non-string account. Please report this bug.", accounts);
        finalAccounts = [];
        break;
      }
    }
    if (!(0, import_fast_deep_equal.default)(this.state.accounts, finalAccounts)) {
      if (isEthAccounts && Array.isArray(this.state.accounts) && this.state.accounts.length > 0 && !isInternal) {
        log.error('WsEmbed: "eth_accounts" unexpectedly updated accounts. Please report this bug.', finalAccounts);
      }
      this.state.accounts = finalAccounts;
      this.emit("accountsChanged", finalAccounts);
    }
    if (this.selectedAddress !== finalAccounts[0]) {
      this.selectedAddress = finalAccounts[0] || null;
    }
  }
  /**
   * Upon receipt of a new chainId and networkVersion, emits corresponding
   * events and sets relevant public state.
   * Does nothing if neither the chainId nor the networkVersion are different
   * from existing values.
   *
   * emits TorusInpageProvider#chainChanged
   * @param networkInfo - An object with network info.
   */
  handleChainChanged({
    chainId
  } = {}) {
    if (!chainId) {
      log.error("WsEmbed: Received invalid network parameters. Please report this bug.", {
        chainId
      });
      return;
    }
    if (chainId === "loading") {
      this.handleDisconnect(true);
    } else {
      this.handleConnect(chainId);
      if (chainId !== this.chainId) {
        this.chainId = chainId;
        if (this.state.initialized) {
          this.emit("chainChanged", this.chainId);
        }
      }
    }
  }
  /**
   * Upon receipt of a new isUnlocked state, sets relevant public state.
   * Calls the accounts changed handler with the received accounts, or an empty
   * array.
   *
   * Does nothing if the received value is equal to the existing value.
   * There are no lock/unlock events.
   *
   * @param opts - Options bag.
   */
  handleUnlockStateChanged({
    accounts,
    isUnlocked
  } = {}) {
    if (typeof isUnlocked !== "boolean") {
      log.error("WsEmbed: Received invalid isUnlocked parameter. Please report this bug.", {
        isUnlocked
      });
      return;
    }
    if (isUnlocked !== this.state.isUnlocked) {
      this.state.isUnlocked = isUnlocked;
      this.handleAccountsChanged(accounts || []);
    }
  }
};
_defineProperty(TorusInPageProvider, "defaultState", {
  accounts: null,
  isConnected: false,
  isUnlocked: false,
  initialized: false,
  isPermanentlyDisconnected: false,
  hasEmittedConnection: false
});
function imgExists(url) {
  return new Promise((resolve, reject) => {
    try {
      const img = document.createElement("img");
      img.onload = () => resolve(true);
      img.onerror = () => resolve(false);
      img.src = url;
    } catch (e) {
      reject(e);
    }
  });
}
var getSiteName = (window2) => {
  const {
    document: document2
  } = window2;
  const siteName = document2.querySelector('head > meta[property="og:site_name"]');
  if (siteName) {
    return siteName.content;
  }
  const metaTitle = document2.querySelector('head > meta[name="title"]');
  if (metaTitle) {
    return metaTitle.content;
  }
  if (document2.title && document2.title.length > 0) {
    return document2.title;
  }
  return window2.location.hostname;
};
async function getSiteIcon(window2) {
  try {
    const {
      document: document2
    } = window2;
    let icon = document2.querySelector('head > link[rel="shortcut icon"]');
    if (icon && await imgExists(icon.href)) {
      return icon.href;
    }
    icon = Array.from(document2.querySelectorAll('head > link[rel="icon"]')).find((_icon) => Boolean(_icon.href));
    if (icon && await imgExists(icon.href)) {
      return icon.href;
    }
    return "";
  } catch (error) {
    return "";
  }
}
var getSiteMetadata = async () => ({
  name: getSiteName(window),
  icon: await getSiteIcon(window)
});
var version = "4.0.4";
var addedVersion = `v${version.split(".")[0]}`;
var WALLET_URLS_DEFAULT = {
  [WS_EMBED_BUILD_ENV.TESTING]: {
    url: "https://develop-wallet.web3auth.io",
    logLevel: "debug"
  },
  [WS_EMBED_BUILD_ENV.DEVELOPMENT]: {
    url: "http://localhost:4050",
    logLevel: "debug"
  },
  [WS_EMBED_BUILD_ENV.STAGING]: {
    url: `https://staging-wallet.web3auth.io/${addedVersion}`,
    logLevel: "debug"
  },
  [WS_EMBED_BUILD_ENV.PRODUCTION]: {
    url: `https://wallet.web3auth.io/${addedVersion}`,
    logLevel: "error"
  }
};
(async function preLoadIframe() {
  try {
    if (typeof document === "undefined") return;
    const torusIframeHtml = document.createElement("link");
    const {
      url: torusUrl
    } = WALLET_URLS_DEFAULT.production;
    torusIframeHtml.href = `${torusUrl}/frame`;
    torusIframeHtml.crossOrigin = "anonymous";
    torusIframeHtml.type = "text/html";
    torusIframeHtml.rel = "prefetch";
    if (torusIframeHtml.relList && torusIframeHtml.relList.supports) {
      if (torusIframeHtml.relList.supports("prefetch")) {
        document.head.appendChild(torusIframeHtml);
      }
    }
  } catch (error) {
    log.warn(error);
  }
})();
/* @__PURE__ */ new Set([COMMUNICATION_JRPC_METHODS.SET_PROVIDER]);
var PROVIDER_UNSAFE_METHODS = /* @__PURE__ */ new Set([SOLANA_METHOD_TYPES.SEND_TRANSACTION, SOLANA_METHOD_TYPES.SIGN_MESSAGE, SOLANA_METHOD_TYPES.SIGN_TRANSACTION, SOLANA_METHOD_TYPES.SIGN_ALL_TRANSACTIONS, EVM_METHOD_TYPES.ETH_SIGN, EVM_METHOD_TYPES.ETH_SIGN_TYPED_DATA_V4, EVM_METHOD_TYPES.PERSONAL_SIGN, EVM_METHOD_TYPES.ETH_TRANSACTION, EVM_METHOD_TYPES.ADD_CHAIN, EVM_METHOD_TYPES.SWITCH_CHAIN, PROVIDER_JRPC_METHODS.WALLET_SWITCH_CHAIN]);
var WsEmbed = class {
  constructor({
    modalZIndex = 99999,
    web3AuthClientId,
    web3AuthNetwork
  }) {
    _defineProperty(this, "isInitialized", void 0);
    _defineProperty(this, "modalZIndex", void 0);
    _defineProperty(this, "provider", void 0);
    _defineProperty(this, "communicationProvider", void 0);
    _defineProperty(this, "buttonPosition", void 0);
    _defineProperty(this, "web3AuthClientId", void 0);
    _defineProperty(this, "web3AuthNetwork", void 0);
    _defineProperty(this, "isPluginMode", void 0);
    _defineProperty(this, "confirmationStrategy", void 0);
    _defineProperty(this, "buildEnv", void 0);
    _defineProperty(this, "embedNonce", randomId());
    this.isInitialized = false;
    this.modalZIndex = modalZIndex;
    this.web3AuthClientId = web3AuthClientId;
    this.web3AuthNetwork = web3AuthNetwork;
  }
  get isLoggedIn() {
    var _this$communicationPr;
    return ((_this$communicationPr = this.communicationProvider) === null || _this$communicationPr === void 0 ? void 0 : _this$communicationPr.isLoggedIn) || false;
  }
  get getBuildEnv() {
    return this.buildEnv;
  }
  async init({
    buildEnv = WS_EMBED_BUILD_ENV.PRODUCTION,
    enableLogging = false,
    chainConfig,
    walletUrls,
    whiteLabel,
    confirmationStrategy = CONFIRMATION_STRATEGY.DEFAULT,
    accountAbstractionConfig
  } = {}) {
    if (this.isInitialized) throw new Error("Already initialized");
    this.buildEnv = buildEnv;
    this.confirmationStrategy = confirmationStrategy;
    const {
      url: torusUrl,
      logLevel
    } = walletUrls && walletUrls[buildEnv] ? _objectSpread2(_objectSpread2({}, WALLET_URLS_DEFAULT[buildEnv]), walletUrls[buildEnv]) : WALLET_URLS_DEFAULT[buildEnv];
    log.info(torusUrl, "url loaded");
    log.setDefaultLevel(logLevel);
    if (enableLogging) log.enableAll();
    else log.disableAll();
    const torusIframeUrl = new URL(torusUrl);
    if (torusIframeUrl.pathname.endsWith("/")) torusIframeUrl.pathname += "frame";
    else torusIframeUrl.pathname += "/frame";
    const hashParams = new URLSearchParams();
    hashParams.append("origin", window.location.origin);
    hashParams.append("nonce", this.embedNonce);
    torusIframeUrl.hash = hashParams.toString();
    const colorScheme = this.getTheme((whiteLabel === null || whiteLabel === void 0 ? void 0 : whiteLabel.mode) || THEME_MODES.light);
    const walletIframe = htmlToElement(`<iframe
        id="walletIframe-${this.embedNonce}"
        class="walletIframe-${this.embedNonce}"
        sandbox="allow-popups allow-scripts allow-same-origin allow-forms allow-modals allow-downloads"
        src="${torusIframeUrl.href}"
        style="display: none; position: fixed; top: 0; right: 0; width: 100%;
        height: 100%; border: none; border-radius: 0; z-index: ${this.modalZIndex.toString()};
        color-scheme: ${colorScheme}"
        allow="clipboard-write"
      ></iframe>`);
    this.buttonPosition = (whiteLabel === null || whiteLabel === void 0 ? void 0 : whiteLabel.buttonPosition) || BUTTON_POSITION.BOTTOM_LEFT;
    const dappMetadata = await getSiteMetadata();
    return new Promise((resolve, reject) => {
      try {
        window.document.body.appendChild(walletIframe);
        const handleMessage = async (ev) => {
          if (ev.origin !== torusIframeUrl.origin) return;
          const {
            message,
            nonce
          } = ev.data || {};
          if (message === SETUP_COMPLETE && nonce === this.embedNonce) {
            window.removeEventListener("message", handleMessage);
            walletIframe.contentWindow.postMessage({
              chainConfig,
              dappMetadata,
              enableLogging,
              web3AuthClientId: this.web3AuthClientId,
              web3AuthNetwork: this.web3AuthNetwork,
              whiteLabel,
              confirmationStrategy,
              accountAbstractionConfig
            }, torusIframeUrl.origin);
            await this.setupWeb3({
              torusUrl,
              walletIframe
            });
            this.isInitialized = true;
            resolve();
          }
        };
        window.addEventListener("message", handleMessage);
      } catch (error) {
        reject(error);
      }
    });
  }
  async login(params = {}) {
    if (!this.isInitialized) throw new Error("Call init() first");
    const isAlreadyFullScreen = this.communicationProvider.isIFrameFullScreen;
    try {
      if (!params.loginProvider && !isAlreadyFullScreen) {
        this.communicationProvider.displayIframe({
          isFull: true
        });
      }
      const res = await new Promise((resolve, reject) => {
        const isSolana = Object.values(SOLANA_CHAIN_IDS).includes(this.provider.chainId);
        const method = isSolana ? SOLANA_METHOD_TYPES.SOLANA_REQUEST_ACCOUNTS : EVM_METHOD_TYPES.ETH_REQUEST_ACCOUNTS;
        this.provider.rpcRequest({
          method,
          params: [params.loginProvider, params.login_hint]
        }, getRpcPromiseCallback(resolve, reject));
      });
      log.info("check: res", res);
      if (Array.isArray(res) && res.length > 0) {
        if (this.confirmationStrategy === CONFIRMATION_STRATEGY.AUTO_APPROVE) log.warn("Confirmation strategy auto approve is not allowed on Embed Mode, using Default instead.");
        return res;
      }
      throw new Error("Login failed");
    } catch (error) {
      log.error("login failed", error);
      throw error;
    } finally {
      if (!isAlreadyFullScreen) this.communicationProvider.displayIframe({
        isFull: false
      });
    }
  }
  async loginWithSessionId(params) {
    if (!this.isInitialized) throw new Error("Call init() first");
    if (!params.sessionId) throw new Error("sessionId is required");
    try {
      const res = await this.communicationProvider.request({
        method: COMMUNICATION_JRPC_METHODS.LOGIN_WITH_SESSION_ID,
        params: [params.sessionId, params.sessionNamespace || ""]
      });
      log.info("check: res", res);
      if (res.success) {
        this.isPluginMode = true;
        if (this.confirmationStrategy === CONFIRMATION_STRATEGY.POPUP) log.warn("Confirmation strategy popup is not allowed on Plugin Mode, using Default instead.");
        return res.success;
      }
      throw new Error("Login failed");
    } catch (error) {
      log.error("login with session id failed", error);
      throw error;
    }
  }
  async logout() {
    if (!this.communicationProvider.isLoggedIn) throw new Error("Not logged in");
    await this.communicationProvider.request({
      method: COMMUNICATION_JRPC_METHODS.LOGOUT,
      params: []
    });
  }
  async cleanUp() {
    var _this$communicationPr2;
    if ((_this$communicationPr2 = this.communicationProvider) !== null && _this$communicationPr2 !== void 0 && _this$communicationPr2.isLoggedIn) {
      await this.logout();
    }
    this.clearInit();
  }
  clearInit() {
    function isElement(element) {
      return element instanceof Element || element instanceof Document;
    }
    const walletIframe = window.document.getElementById(`walletIframe-${this.embedNonce}`);
    if (isElement(walletIframe)) {
      walletIframe.remove();
    }
    this.isInitialized = false;
  }
  async getUserInfo() {
    const userInfoResponse = await this.communicationProvider.request({
      method: COMMUNICATION_JRPC_METHODS.USER_INFO,
      params: []
    });
    return userInfoResponse;
  }
  async showWalletConnectScanner(showWalletConnectParams) {
    const isShow = showWalletConnectParams ? showWalletConnectParams.show : true;
    this.communicationProvider.displayIframe({
      isFull: isShow
    });
    try {
      await this.communicationProvider.request({
        method: COMMUNICATION_JRPC_METHODS.SHOW_WALLET_CONNECT,
        params: showWalletConnectParams
      });
    } catch (_) {
      this.communicationProvider.displayIframe({
        isFull: false
      });
    }
  }
  async showWalletUi(showWalletUiParams) {
    const isShow = showWalletUiParams ? showWalletUiParams.show : true;
    this.communicationProvider.displayIframe({
      isFull: isShow
    });
    try {
      await this.communicationProvider.request({
        method: COMMUNICATION_JRPC_METHODS.SHOW_WALLET_UI,
        params: showWalletUiParams
      });
    } catch (_) {
      this.communicationProvider.displayIframe({
        isFull: false
      });
    }
  }
  async showCheckout(showCheckoutParams) {
    const isShow = showCheckoutParams ? showCheckoutParams.show : true;
    this.communicationProvider.displayIframe({
      isFull: isShow
    });
    try {
      await this.communicationProvider.request({
        method: COMMUNICATION_JRPC_METHODS.SHOW_CHECKOUT,
        params: showCheckoutParams
      });
    } catch (_) {
      this.communicationProvider.displayIframe({
        isFull: false
      });
    }
  }
  async showSwap(shoSwapParams) {
    const isShow = shoSwapParams ? shoSwapParams.show : true;
    this.communicationProvider.displayIframe({
      isFull: isShow
    });
    try {
      await this.communicationProvider.request({
        method: COMMUNICATION_JRPC_METHODS.SHOW_SWAP,
        params: shoSwapParams
      });
    } catch (_) {
      this.communicationProvider.displayIframe({
        isFull: false
      });
    }
  }
  getConfirmationStrategyFinal(payload) {
    let confirmationStrategyFinal = this.confirmationStrategy;
    if (!Array.isArray(payload) && PROVIDER_UNSAFE_METHODS.has(payload.method) && this.confirmationStrategy !== CONFIRMATION_STRATEGY.MODAL && !this.isPluginMode) {
      confirmationStrategyFinal = CONFIRMATION_STRATEGY.POPUP;
    }
    return confirmationStrategyFinal;
  }
  getTheme(theme) {
    if (theme === THEME_MODES.light) return "light";
    if (theme === THEME_MODES.dark) return "dark";
    return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
  }
  async setupWeb3(providerParams) {
    log.info("setupWeb3 running");
    const providerStream = new BasePostMessageStream({
      name: "embed_torus",
      target: "iframe_torus",
      targetWindow: providerParams.walletIframe.contentWindow,
      targetOrigin: new URL(providerParams.torusUrl).origin
    });
    const communicationStream = new BasePostMessageStream({
      name: "embed_communication",
      target: "iframe_communication",
      targetWindow: providerParams.walletIframe.contentWindow,
      targetOrigin: new URL(providerParams.torusUrl).origin
    });
    const inPageProvider = new TorusInPageProvider(providerStream, {});
    const communicationProvider = new CommunicationProvider(communicationStream, {}, {
      buttonPosition: this.buttonPosition
    });
    inPageProvider.tryWindowHandle = (payload, cb) => {
      const _payload = payload;
      const confirmationStrategyFinal = this.getConfirmationStrategyFinal(payload);
      const {
        allowWalletService
      } = communicationProvider;
      if (confirmationStrategyFinal === CONFIRMATION_STRATEGY.POPUP && allowWalletService) {
        const windowId = randomId();
        communicationProvider.handleWindow(windowId, {
          target: "_blank",
          features: getPopupFeatures(FEATURES_CONFIRM_WINDOW),
          timeout: 500
        });
        _payload.windowId = windowId;
      }
      inPageProvider.rpcEngine.handle(_payload, cb);
    };
    communicationProvider.tryWindowHandle = (payload, cb) => {
      const _payload = payload;
      const confirmationStrategyFinal = this.getConfirmationStrategyFinal(payload);
      const {
        allowWalletService
      } = communicationProvider;
      if (confirmationStrategyFinal === CONFIRMATION_STRATEGY.POPUP && allowWalletService) {
        const windowId = randomId();
        communicationProvider.handleWindow(windowId, {
          target: "_blank",
          features: getPopupFeatures(FEATURES_PROVIDER_CHANGE_WINDOW),
          // todo: are these features generic for all
          timeout: 500
        });
        _payload.params.windowId = windowId;
      }
      communicationProvider.rpcEngine.handle(_payload, cb);
    };
    const detectAccountRequestPrototypeModifier = (m) => {
      const originalMethod = inPageProvider[m];
      const self = this;
      inPageProvider[m] = function providerFunc(request, cb) {
        const {
          method,
          params = []
        } = request;
        if (method === EVM_METHOD_TYPES.ETH_REQUEST_ACCOUNTS || method === SOLANA_METHOD_TYPES.SOLANA_REQUEST_ACCOUNTS) {
          if (!cb) return self.login({
            loginProvider: params[0]
          });
          self.login({
            loginProvider: params[0]
          }).then((res) => cb(null, res)).catch((err) => cb(err));
        }
        return originalMethod.apply(this, [request, cb]);
      };
    };
    detectAccountRequestPrototypeModifier("request");
    detectAccountRequestPrototypeModifier("sendAsync");
    detectAccountRequestPrototypeModifier("send");
    const proxiedInPageProvider = new Proxy(inPageProvider, {
      // straight up lie that we deleted the property so that it doesn't
      // throw an error in strict mode
      deleteProperty: () => true
    });
    const proxiedCommunicationProvider = new Proxy(communicationProvider, {
      // straight up lie that we deleted the property so that it doesn't
      // throw an error in strict mode
      deleteProperty: () => true
    });
    this.provider = proxiedInPageProvider;
    this.communicationProvider = proxiedCommunicationProvider;
    log.info("test setupWeb3 ");
    await Promise.all([inPageProvider.initializeState(), communicationProvider.initializeState(_objectSpread2(_objectSpread2({}, providerParams), {}, {
      torusIframeId: providerParams.walletIframe.id
    }))]);
    log.debug("WsEmbed - injected provider");
  }
};

// node_modules/@web3auth/wallet-services-plugin/dist/lib.esm/plugin.js
var WalletServicesPlugin = class extends SafeEventEmitter {
  constructor(options = {}) {
    super();
    _defineProperty(this, "name", EVM_PLUGINS.WALLET_SERVICES);
    _defineProperty(this, "status", PLUGIN_STATUS.DISCONNECTED);
    _defineProperty(this, "SUPPORTED_ADAPTERS", [WALLET_ADAPTERS.AUTH, WALLET_ADAPTERS.SFA]);
    _defineProperty(this, "pluginNamespace", PLUGIN_NAMESPACES.MULTICHAIN);
    _defineProperty(this, "wsEmbedInstance", void 0);
    _defineProperty(this, "provider", null);
    _defineProperty(this, "web3auth", null);
    _defineProperty(this, "isInitialized", false);
    _defineProperty(this, "walletInitOptions", null);
    const {
      wsEmbedOpts,
      walletInitOptions
    } = options;
    this.wsEmbedInstance = new WsEmbed(wsEmbedOpts || {});
    this.walletInitOptions = walletInitOptions || {};
  }
  get proxyProvider() {
    return this.wsEmbedInstance.provider ? this.wsEmbedInstance.provider : null;
  }
  async initWithWeb3Auth(web3auth, whiteLabel) {
    var _this$walletInitOptio, _this$web3auth$coreOp;
    if (this.isInitialized) return;
    if (!web3auth) throw WalletServicesPluginError.web3authRequired();
    if (web3auth.provider && !this.SUPPORTED_ADAPTERS.includes(web3auth.connectedAdapterName)) throw WalletServicesPluginError.notInitialized();
    if (![CHAIN_NAMESPACES.EIP155, CHAIN_NAMESPACES.SOLANA].includes(web3auth.coreOptions.chainConfig.chainNamespace)) throw WalletServicesPluginError.unsupportedChainNamespace();
    if (web3auth.provider) {
      this.provider = web3auth.provider;
    }
    this.web3auth = web3auth;
    const mergedWhitelabelSettings = _objectSpread2(_objectSpread2({}, whiteLabel), this.walletInitOptions.whiteLabel || {});
    const {
      logoDark,
      logoLight
    } = mergedWhitelabelSettings || {};
    if (!logoDark || !logoLight) throw WalletServicesPluginError.invalidParams("logoDark and logoLight are required in whiteLabel config");
    this.wsEmbedInstance.web3AuthClientId = this.web3auth.coreOptions.clientId;
    this.wsEmbedInstance.web3AuthNetwork = this.web3auth.coreOptions.web3AuthNetwork;
    this.subscribeToWeb3AuthEvents(web3auth);
    const connectedChainConfig = web3auth.coreOptions.chainConfig;
    if (!connectedChainConfig.blockExplorerUrl) throw WalletServicesPluginError.invalidParams("blockExplorerUrl is required in chainConfig");
    if (!connectedChainConfig.displayName) throw WalletServicesPluginError.invalidParams("displayName is required in chainConfig");
    if (!connectedChainConfig.logo) throw WalletServicesPluginError.invalidParams("logo is required in chainConfig");
    if (!connectedChainConfig.ticker) throw WalletServicesPluginError.invalidParams("ticker is required in chainConfig");
    if (!connectedChainConfig.tickerName) throw WalletServicesPluginError.invalidParams("tickerName is required in chainConfig");
    const hasAaProvider = web3auth.coreOptions.accountAbstractionProvider && (web3auth.connectedAdapterName === WALLET_ADAPTERS.AUTH || web3auth.connectedAdapterName !== WALLET_ADAPTERS.AUTH && web3auth.coreOptions.useAAWithExternalWallet);
    let accountAbstractionConfig;
    if (hasAaProvider) {
      var _web3auth$coreOptions, _web3auth$coreOptions2, _web3auth$coreOptions3, _web3auth$coreOptions4, _web3auth$coreOptions5;
      const smartAccountAddress = (_web3auth$coreOptions = web3auth.coreOptions.accountAbstractionProvider) === null || _web3auth$coreOptions === void 0 ? void 0 : _web3auth$coreOptions.smartAccount.address;
      const smartAccountType = (_web3auth$coreOptions2 = web3auth.coreOptions.accountAbstractionProvider) === null || _web3auth$coreOptions2 === void 0 ? void 0 : _web3auth$coreOptions2.config.smartAccountInit.name;
      const paymasterConfig = (_web3auth$coreOptions3 = web3auth.coreOptions.accountAbstractionProvider) === null || _web3auth$coreOptions3 === void 0 || (_web3auth$coreOptions3 = _web3auth$coreOptions3.config) === null || _web3auth$coreOptions3 === void 0 ? void 0 : _web3auth$coreOptions3.paymasterConfig;
      const bundlerConfig = (_web3auth$coreOptions4 = web3auth.coreOptions.accountAbstractionProvider) === null || _web3auth$coreOptions4 === void 0 || (_web3auth$coreOptions4 = _web3auth$coreOptions4.config) === null || _web3auth$coreOptions4 === void 0 ? void 0 : _web3auth$coreOptions4.bundlerConfig;
      const smartAccountConfig = (_web3auth$coreOptions5 = web3auth.coreOptions.accountAbstractionProvider) === null || _web3auth$coreOptions5 === void 0 ? void 0 : _web3auth$coreOptions5.config.smartAccountInit.options;
      accountAbstractionConfig = {
        smartAccountAddress: smartAccountAddress || void 0,
        smartAccountType: smartAccountType || void 0,
        paymasterConfig: paymasterConfig || void 0,
        bundlerConfig: bundlerConfig || void 0,
        smartAccountConfig: smartAccountConfig || void 0
      };
    } else if ((_this$walletInitOptio = this.walletInitOptions) !== null && _this$walletInitOptio !== void 0 && _this$walletInitOptio.accountAbstractionConfig && Object.keys(this.walletInitOptions.accountAbstractionConfig).length > 0) {
      accountAbstractionConfig = this.walletInitOptions.accountAbstractionConfig;
    }
    const finalInitOptions = _objectSpread2(_objectSpread2({}, this.walletInitOptions), {}, {
      chainConfig: connectedChainConfig,
      enableLogging: (_this$web3auth$coreOp = this.web3auth.coreOptions) === null || _this$web3auth$coreOp === void 0 ? void 0 : _this$web3auth$coreOp.enableLogging,
      whiteLabel: mergedWhitelabelSettings,
      accountAbstractionConfig
    });
    await this.wsEmbedInstance.init(finalInitOptions);
    this.isInitialized = true;
    this.status = PLUGIN_STATUS.READY;
    this.emit(PLUGIN_EVENTS.READY);
  }
  initWithProvider() {
    throw new Error("Method not implemented.");
  }
  async connect({
    sessionId,
    sessionNamespace
  }) {
    if (!this.isInitialized) throw WalletServicesPluginError.notInitialized();
    this.emit(PLUGIN_EVENTS.CONNECTING);
    this.status = PLUGIN_STATUS.CONNECTING;
    if (!this.provider) {
      var _this$web3auth;
      if ((_this$web3auth = this.web3auth) !== null && _this$web3auth !== void 0 && _this$web3auth.provider) {
        this.provider = this.web3auth.provider;
      }
    }
    if (this.web3auth.status !== ADAPTER_STATUS.CONNECTED) {
      throw WalletServicesPluginError.web3AuthNotConnected();
    } else if (!this.web3auth.provider) {
      throw WalletServicesPluginError.providerRequired();
    }
    if (!sessionId) {
      throw WalletServicesPluginError.web3AuthNotConnected();
    }
    try {
      await this.wsEmbedInstance.loginWithSessionId({
        sessionId,
        sessionNamespace
      });
      this.subscribeToProviderEvents(this.provider);
      this.subscribeToWalletEvents();
      this.emit(PLUGIN_EVENTS.CONNECTED);
      this.status = PLUGIN_STATUS.CONNECTED;
    } catch (error) {
      loglevel.error(error);
      this.status = PLUGIN_STATUS.ERRORED;
      this.emit(PLUGIN_EVENTS.ERRORED, {
        error: error.message || "Something went wrong"
      });
    }
  }
  async showWalletConnectScanner(showWalletConnectParams) {
    if (!this.wsEmbedInstance.isLoggedIn) throw WalletServicesPluginError.walletPluginNotConnected();
    return this.wsEmbedInstance.showWalletConnectScanner(showWalletConnectParams);
  }
  async showCheckout(showCheckoutParams) {
    if (!this.wsEmbedInstance.isLoggedIn) throw WalletServicesPluginError.walletPluginNotConnected();
    return this.wsEmbedInstance.showCheckout(showCheckoutParams);
  }
  async showWalletUi(showWalletUiParams) {
    if (!this.wsEmbedInstance.isLoggedIn) throw WalletServicesPluginError.walletPluginNotConnected();
    return this.wsEmbedInstance.showWalletUi(showWalletUiParams);
  }
  async showSwap(showSwapParams) {
    if (!this.wsEmbedInstance.isLoggedIn) throw WalletServicesPluginError.walletPluginNotConnected();
    return this.wsEmbedInstance.showSwap(showSwapParams);
  }
  async cleanup() {
    return this.wsEmbedInstance.cleanUp();
  }
  async disconnect() {
    if (this.wsEmbedInstance.isLoggedIn) {
      await this.wsEmbedInstance.logout();
      this.emit(PLUGIN_EVENTS.DISCONNECTED);
      this.status = PLUGIN_STATUS.DISCONNECTED;
    } else {
      throw WalletServicesPluginError.invalidSession("Wallet Services plugin is not connected");
    }
  }
  subscribeToWalletEvents() {
    var _this$wsEmbedInstance;
    (_this$wsEmbedInstance = this.wsEmbedInstance) === null || _this$wsEmbedInstance === void 0 || _this$wsEmbedInstance.provider.on("accountsChanged", (accounts = []) => {
      if (accounts.length === 0) {
        var _this$web3auth2, _this$web3auth3;
        if (((_this$web3auth2 = this.web3auth) === null || _this$web3auth2 === void 0 ? void 0 : _this$web3auth2.status) === ADAPTER_STATUS.CONNECTED) (_this$web3auth3 = this.web3auth) === null || _this$web3auth3 === void 0 || _this$web3auth3.logout();
      }
    });
  }
  subscribeToProviderEvents(provider) {
    provider.on("accountsChanged", (accounts = []) => {
      this.setSelectedAddress(accounts[0]);
    });
    provider.on("chainChanged", (chainId) => {
      this.setChainID(parseInt(chainId, 16));
    });
  }
  subscribeToWeb3AuthEvents(web3Auth) {
    web3Auth.on(ADAPTER_EVENTS.CONNECTED, (data) => {
      this.provider = data.provider || web3Auth.provider;
      if (!this.provider) throw WalletServicesPluginError.web3AuthNotConnected();
      this.subscribeToProviderEvents(this.provider);
    });
    web3Auth.on(ADAPTER_EVENTS.DISCONNECTED, async () => {
      this.provider = null;
      if (this.wsEmbedInstance.isLoggedIn) {
        await this.wsEmbedInstance.logout();
      }
    });
  }
  async sessionConfig() {
    if (!this.provider) throw WalletServicesPluginError.web3AuthNotConnected();
    const [accounts, chainId, chainConfig] = await Promise.all([this.provider.request({
      method: "eth_accounts"
    }), this.provider.request({
      method: "eth_chainId"
    }), this.provider.request({
      method: "eth_provider_config"
    })]);
    return {
      chainId: parseInt(chainId, 16),
      accounts,
      chainConfig
    };
  }
  async walletServicesSessionConfig() {
    if (!this.wsEmbedInstance.provider) throw WalletServicesPluginError.web3AuthNotConnected();
    const [accounts, chainId] = await Promise.all([this.wsEmbedInstance.provider.request({
      method: "eth_accounts"
    }), this.wsEmbedInstance.provider.request({
      method: "eth_chainId"
    })]);
    return {
      chainId: parseInt(chainId, 16),
      accounts
    };
  }
  async setSelectedAddress(address) {
    var _walletServicesSessio;
    if (this.web3auth.status !== ADAPTER_STATUS.CONNECTED) throw WalletServicesPluginError.web3AuthNotConnected();
    const walletServicesSessionConfig = await this.walletServicesSessionConfig();
    if (address !== ((_walletServicesSessio = walletServicesSessionConfig.accounts) === null || _walletServicesSessio === void 0 ? void 0 : _walletServicesSessio[0])) {
      throw WalletServicesPluginError.invalidSession();
    }
  }
  async setChainID(chainId) {
    const [sessionConfig, walletServicesSessionConfig] = await Promise.all([this.sessionConfig(), this.walletServicesSessionConfig()]);
    const {
      chainConfig
    } = sessionConfig || {};
    if (!chainConfig.blockExplorerUrl) throw WalletServicesPluginError.invalidParams("blockExplorerUrl is required in chainConfig");
    if (!chainConfig.displayName) throw WalletServicesPluginError.invalidParams("displayName is required in chainConfig");
    if (!chainConfig.logo) throw WalletServicesPluginError.invalidParams("logo is required in chainConfig");
    if (!chainConfig.ticker) throw WalletServicesPluginError.invalidParams("ticker is required in chainConfig");
    if (!chainConfig.tickerName) throw WalletServicesPluginError.invalidParams("tickerName is required in chainConfig");
    if (chainId !== walletServicesSessionConfig.chainId && chainConfig) {
      try {
        var _this$wsEmbedInstance2, _this$wsEmbedInstance3;
        await ((_this$wsEmbedInstance2 = this.wsEmbedInstance.provider) === null || _this$wsEmbedInstance2 === void 0 ? void 0 : _this$wsEmbedInstance2.request({
          method: "wallet_addEthereumChain",
          params: [{
            chainId: chainConfig.chainId,
            chainName: chainConfig.displayName,
            rpcUrls: [chainConfig.rpcTarget],
            blockExplorerUrls: [chainConfig.blockExplorerUrl],
            nativeCurrency: {
              name: chainConfig.tickerName,
              symbol: chainConfig.ticker,
              decimals: chainConfig.decimals || 18
            },
            iconUrls: [chainConfig.logo]
          }]
        }).catch(() => {
          loglevel.error("WalletServicesPlugin: Error adding chain");
        }));
        await ((_this$wsEmbedInstance3 = this.wsEmbedInstance.provider) === null || _this$wsEmbedInstance3 === void 0 ? void 0 : _this$wsEmbedInstance3.request({
          method: "wallet_switchEthereumChain",
          params: [{
            chainId: chainConfig.chainId
          }]
        }));
      } catch (error) {
        loglevel.error("WalletServicesPlugin: Error switching chain");
      }
    }
  }
};
export {
  BUTTON_POSITION,
  CONFIRMATION_STRATEGY,
  WalletServicesPlugin
};
//# sourceMappingURL=@web3auth_wallet-services-plugin.js.map
